
#include <iostream>
#include <windows.h>

using namespace std;
int main()

{
	::ShowWindow(::GetConsoleWindow(), SW_HIDE);
	int x = 0;
	int y = 0;

	
	POINT pt;
	POINT lt;
	GetCursorPos(&pt);
	int (pt.x = 0);
	int(pt.y = 0);
		int sx = 1;
		int sy = 1;
		int sw = (pt.x * 6);
		int sz = (pt.y * 6);
		int sv = (pt.x * 6);
		
			while (1) {
		GetCursorPos(&pt);
		if ((pt.x++) && (pt.y++));
		{
			GetCursorPos(&lt);
			if ((lt.x < pt.x) && (lt.y < pt.y));
			{

				

			Sleep(666.7);

			bool setFPSLimit(100);

					mouse_event(MOUSEEVENTF_MOVE, sw, sz, NULL, NULL);

					typedef struct tagINPUT {
						DWORD type;
						union {
							MOUSEINPUT    sw;
							KEYBDINPUT    sz;
							HARDWAREINPUT sv;
						} DUMMYUNIONNAME;
					} INPUT, * PINPUT, * LPINPUT;
				}
			}
		
			GetCursorPos(&pt);
			if ((pt.x++) && (pt.y++));
			{
				GetCursorPos(&lt);
				if ((lt.x < pt.x) && (lt.y < pt.y));
				{



					Sleep(600);

					bool setFPSLimit(100);

					mouse_event(MOUSEEVENTF_MOVE, sw, sz, NULL, NULL);

					typedef struct tagINPUT {
						DWORD type;
						union {
							MOUSEINPUT    sw;
							KEYBDINPUT    sz;
							HARDWAREINPUT sv;
						} DUMMYUNIONNAME;
					} INPUT, * PINPUT, * LPINPUT;
				}
			}
			GetCursorPos(&pt);
			if ((pt.x++) && (pt.y++));
			{
				GetCursorPos(&lt);
				if ((lt.x < pt.x) && (lt.y < pt.y));
				{



					Sleep(545.5);
					bool setFPSLimit(100);


					mouse_event(MOUSEEVENTF_MOVE, sw, sz, NULL, NULL);

					typedef struct tagINPUT {
						DWORD type;
						union {
							MOUSEINPUT    sw;
							KEYBDINPUT    sz;
							HARDWAREINPUT sv;
						} DUMMYUNIONNAME;
					} INPUT, * PINPUT, * LPINPUT;
				}
			}
			GetCursorPos(&pt);
			if ((pt.x++) && (pt.y++));
			{
				GetCursorPos(&lt);
				if ((lt.x < pt.x) && (lt.y < pt.y));
				{



					Sleep(500);

					bool setFPSLimit(100);

					mouse_event(MOUSEEVENTF_MOVE, sw, sz, NULL, NULL);

					typedef struct tagINPUT {
						DWORD type;
						union {
							MOUSEINPUT    sw;
							KEYBDINPUT    sz;
							HARDWAREINPUT sv;
						} DUMMYUNIONNAME;
					} INPUT, * PINPUT, * LPINPUT;
				}
			}

			GetCursorPos(&pt);
			if ((pt.x++) && (pt.y++));
			{
				GetCursorPos(&lt);
				if ((lt.x < pt.x) && (lt.y < pt.y));
				{



					Sleep(468.8);
					bool setFPSLimit(100);


					mouse_event(MOUSEEVENTF_MOVE, sw, sz, NULL, NULL);

					typedef struct tagINPUT {
						DWORD type;
						union {
							MOUSEINPUT    sw;
							KEYBDINPUT    sz;
							HARDWAREINPUT sv;
						} DUMMYUNIONNAME;
					} INPUT, * PINPUT, * LPINPUT;
				}
			}
			GetCursorPos(&pt);
			if ((pt.x++) && (pt.y++));
			{
				GetCursorPos(&lt);
				if ((lt.x < pt.x) && (lt.y < pt.y));
				{

			

					Sleep(461.5);
					bool setFPSLimit(100);


					mouse_event(MOUSEEVENTF_MOVE, sw, sz, NULL, NULL);

					typedef struct tagINPUT {
						DWORD type;
						union {
							MOUSEINPUT    sw;
							KEYBDINPUT    sz;
							HARDWAREINPUT sv;
						} DUMMYUNIONNAME;
					} INPUT, * PINPUT, * LPINPUT;
				}


			}
		
			

		if ((GetKeyState(VK_INSERT) & 0x100) != 0)
		{

			exit(0);
		}
		else
		{
			bool setFPSLimit(60);
		}
	}
	
	return 0;
}

